// src/modules/agenda/agenda.service.ts
import { Injectable, Logger, BadRequestException } from '@nestjs/common';
import { DataSource } from 'typeorm';

/** DTO interno mínimo para anular; evita depender de otros archivos */
type AnularParams = {
  motivo: string;
  motivoCodigo?: string | null;
};

@Injectable()
export class AgendaService {
  private readonly logger = new Logger(AgendaService.name);

  constructor(private readonly dataSource: DataSource) {}

  /** Util: normaliza el resultado de DataSource.query a un array de una orden */
  private one(res: any[]): any[] {
    if (Array.isArray(res) && res.length > 0) {
      return res.map((r) => r);
    }
    return [];
  }

  /** Asignar agenda (fecha/turno/técnico) y dejar estado=agendada */
  async asignarPorCodigo(
    codigo: string,
    fecha: string,
    turno: 'am' | 'pm',
    tecnicoId?: string | null,
  ) {
    const res = await this.dataSource.query(
      `
      UPDATE ordenes
      SET
        agendado_para = $2::date,
        turno         = $3::text,
        agendada_at   = now(),
        estado        = 'agendada'
        tecnico_id    = COALESCE($4::uuid, tecnico_id)
      WHERE codigo = $1
      RETURNING
        codigo,
        estado,
        to_char(agendado_para,'YYYY-MM-DD') AS "agendadoPara",
        turno,
        agendada_at AS "agendadaAt",
        tecnico_id  AS "tecnicoId",
      `,
      [codigo, fecha, turno, tecnicoId ?? null],
    );

    const orden = this.one(res);
    const payload = { ok: true, orden };
    this.logger.log(`[ASIGNAR] ${codigo} -> ${JSON.stringify(payload)}`);
    return payload;
  }

  /**
   * Reagendar agenda (fecha/turno). Ahora acepta opcionalmente:
   *  - motivoCodigo (preferido)
   *  - motivo (legacy: si te llega texto/código, lo usamos igual)
   *
   * Firma compatible con el controller actual: los 2 primeros args son obligatorios;
   * motivo es opcional y no rompe llamadas existentes.
   */
  async reagendarPorCodigo(
    codigo: string,
    fecha: string,
    turno: 'am' | 'pm',
    motivoCodigo?: string | null,
    motivo?: string | null,
  ) {
    // preferimos motivoCodigo; si no viene, usamos 'motivo' tal cual (si viene)
    const motivoEff =
      (motivoCodigo && motivoCodigo.trim()) ||
      (motivo && motivo.trim()) ||
      null;

    const res = await this.dataSource.query(
      `
      UPDATE ordenes
      SET
        agendado_para = $2::date,
        turno         = $3::text,
        agendada_at   = now(),
        estado        = 'agendada'
        , motivo_reagenda         = COALESCE($4::text, motivo_reagenda)
        , motivo_reagenda_codigo  = COALESCE($5::text, motivo_reagenda_codigo)
        -- si enviaron motivo de reagenda, lo persistimos en motivo_codigo
        motivo_codigo = COALESCE($4::text, motivo_codigo)
      WHERE codigo = $1
      RETURNING
        codigo,
        estado,
        to_char(agendado_para,'YYYY-MM-DD') AS "agendadoPara",
        turno,
        agendada_at AS "agendadaAt",
        tecnico_id  AS "tecnicoId",
        motivo_reagenda        AS "motivo",
        motivo_reagenda_codigo AS "motivoCodigo",
        motivo_codigo AS "motivoCodigo"
      `,
      [codigo, fecha, turno, motivoEff],
    );

    const orden = this.one(res);
    const payload = { ok: true, orden };
    this.logger.log(`[REAGENDAR] ${codigo} -> ${JSON.stringify(payload)}`);
    return payload;
  }

  /** Cancelar agenda (mantiene estado actual, solo limpia fecha/turno/marca de agenda) */
  async cancelarPorCodigo(codigo: string) {
    const res = await this.dataSource.query(
      `
      UPDATE ordenes
      SET
        agendado_para = NULL,
        turno         = NULL,
        agendada_at   = NULL
        -- NOTA: estado se mantiene; se usa 'anular' para pasar a cancelada
      WHERE codigo = $1
      RETURNING
        codigo,
        estado,
        to_char(agendado_para,'YYYY-MM-DD') AS "agendadoPara",
        turno,
        agendada_at AS "agendadaAt",
        tecnico_id  AS "tecnicoId",
      `,
      [codigo],
    );

    const orden = this.one(res);
    const payload = { ok: true, orden };
    this.logger.log(`[CANCELAR] ${codigo} -> ${JSON.stringify(payload)}`);
    return payload;
  }

  /** Anular orden: estado=cancelada, guarda motivo/s, libera agenda y técnico */
  async anularPorCodigo(codigo: string, dto: AnularParams) {
    const { motivo, motivoCodigo } = dto;
    if (!motivo || !motivo.trim()) {
      throw new BadRequestException('motivo es obligatorio');
    }

    const res = await this.dataSource.query(
      `
      UPDATE ordenes
      SET
        estado              = 'cancelada',
        motivo_cancelacion  = $2,
        motivo_codigo       = $3,
        cancelada_at        = now(),
        -- liberar agenda
        agendado_para       = NULL,
        turno               = NULL,
        agendada_at         = NULL,
        -- liberar técnico
        tecnico_id          = NULL
      WHERE codigo = $1
      RETURNING
        codigo,
        estado,
        motivo_cancelacion AS "motivo",
        motivo_codigo      AS "motivoCodigo",
        cancelada_at       AS "canceladaAt",
        to_char(agendado_para,'YYYY-MM-DD') AS "agendadoPara",
        turno,
        agendada_at        AS "agendadaAt",
        tecnico_id         AS "tecnicoId",
        motivo_reagenda        AS "motivo",
        motivo_reagenda_codigo AS "motivoCodigo"
      `,
      [codigo, motivo.trim(), motivoCodigo ?? null],
    );

    const orden = this.one(res);
    const payload = { ok: true, orden };
    this.logger.log(`[ANULAR] ${codigo} -> ${JSON.stringify(payload)}`);
    return payload;
  }
}
